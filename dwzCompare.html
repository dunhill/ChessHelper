<!DOCTYPE html>
<html lang="de">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Schachbund Multi-Spieler DWZ Chart</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 40px;
      background-color: #f7f7f7;
    }

    h1 {
      color: #333;
      margin-bottom: 10px;
    }

    input,
    button {
      display: block;
      margin-top: 10px;
      width: 100%;
      font-size: 1rem;
      padding: 8px;
    }

    button {
      background-color: #0077cc;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }

    button:hover {
      background-color: #005fa3;
    }

    .player-section {
      margin-top: 40px;
      background: white;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 10px;
    }

    th,
    td {
      border: 1px solid #ddd;
      padding: 6px 10px;
      text-align: left;
    }

    th {
      background-color: #0077cc;
      color: white;
    }

    tr:nth-child(even) {
      background-color: #f2f2f2;
    }

    #chartContainer {
      margin-top: 50px;
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
    }

    /* Cache status widget */
    #cacheStatus {
      position: fixed;
      right: 12px;
      bottom: 12px;
      background: #ffffffcc;
      backdrop-filter: blur(4px);
      padding: 8px 10px;
      border: 1px solid #ddd;
      border-radius: 6px;
      font-size: 12px;
      color: #222;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.08);
      z-index: 9999;
    }

    /* Chart controls placed above player tables */
    #chartArea {
      margin-top: 20px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .chart-controls {
      display: flex;
      align-items: center;
      justify-content: flex-start;
      gap: 8px;
    }

    /* Ensure checkbox is not stretched by the generic input rule */
    .chart-controls input[type="checkbox"] {
      display: inline-block;
      width: auto;
      height: auto;
      margin: 0;
      transform: scale(1.05);
      cursor: pointer;
    }

    .chart-controls label {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      cursor: pointer;
      font-size: 14px;
      color: #222;
    }
  </style>
</head>

<body>
  <h1>DWZ-Verlauf mehrerer Spieler</h1>
  <label for="pkz">Spieler-IDs (kommagetrennt):</label>
  <input type="text" id="pkz" placeholder="z. B. 12345,67890">
  <button id="fetchBtn">Daten abrufen</button>

  <!-- Chart and controls moved above the player tables -->
  <div id="chartArea">
    <div class="chart-controls">
      <label for="ageAdjustCheckbox"><input type="checkbox" id="ageAdjustCheckbox"> Altersanpassung</label>
    </div>

    <div id="chartContainer">
      <canvas id="dwzChart" width="800" height="400"></canvas>
    </div>
  </div>

  <div id="playersContainer"></div>

  <!-- Visual cache status (updated at runtime) -->
  <div id="cacheStatus" aria-live="polite" title="Cache-Treffer / -Fehler">Cache: Hits 0 · Misses 0</div>

  <!-- Chart.js + Luxon for time axis -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/luxon@3.3.0/build/global/luxon.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon@1.1.0/dist/chartjs-adapter-luxon.min.js"></script>

  <script>
    const chartColors = [
      '#0077cc', '#ff5733', '#28a745', '#9b59b6',
      '#ff9800', '#00bcd4', '#e91e63', '#795548'
    ];

    // Simple localStorage cache for tournament dates
    const TOURNAMENT_CACHE_KEY = 'ch_tournament_dates_v2';
    // Tournament dates are fixed; do not expire in the cache.

    // Previous player input key + helpers
    const PREV_INPUT_KEY = 'ch_prev_pkz_v1';
    function loadPreviousInput() {
      try { return localStorage.getItem(PREV_INPUT_KEY) || ''; }
      catch (e) { return ''; }
    }
    function savePreviousInput(value) {
      try { localStorage.setItem(PREV_INPUT_KEY, value || ''); }
      catch (e) { /* ignore storage errors */ }
    }

    function loadTournamentCache() {
      try { return JSON.parse(localStorage.getItem(TOURNAMENT_CACHE_KEY) || '{}'); }
      catch (e) { return {}; }
    }
    function saveTournamentCache(cache) {
      try { localStorage.setItem(TOURNAMENT_CACHE_KEY, JSON.stringify(cache)); }
      catch (e) { /* ignore storage errors */ }
    }
    // restore previous input on page load
    try {
      const prev = loadPreviousInput();
      if (prev) document.getElementById('pkz').value = prev;
    } catch (e) { /* ignore */ }

    // In-memory shared cache for the current run to avoid localStorage race overwrites
    // and to reuse loaded entries across parallel fetchTournamentDate calls.
    // It is initialized once per "run" (button click) and persisted back
    // to localStorage after each player's data has been processed.
    let inMemoryTournamentCache = null;
    // pending fetch promises to deduplicate simultaneous remote lookups for same code
    const pendingTournamentFetches = {};

    // last fetched players for re-rendering when checkbox changes
    let lastPlayers = null;

    // Visual cache counters + updater
    let cacheHits = 0;
    let cacheMisses = 0;
    const cacheStatusEl = document.getElementById('cacheStatus');
    function updateCacheStatus() {
      if (!cacheStatusEl) return;
      // show number of cached entries as well (use in-memory cache if available,
      // otherwise read from localStorage)
      const cacheSource = inMemoryTournamentCache || loadTournamentCache();
      const size = cacheSource ? Object.keys(cacheSource).length : 0;
      cacheStatusEl.textContent = `Cache: Hits ${cacheHits} · Misses ${cacheMisses} · Einträge ${size}`;
    }

    // If a cached entry exists, return it. Otherwise fetch and store.
    async function fetchTournamentDate(tournamentCode) {
      if (!tournamentCode) return null;
      // Ensure we have the run-local cache loaded once
      if (!inMemoryTournamentCache) {
        inMemoryTournamentCache = loadTournamentCache();
      }

      const code = (tournamentCode || '').trim();
      // cache stores the date string (or null) directly. presence (not undefined)
      // indicates a cached value that never expires.
      const entry = Object.prototype.hasOwnProperty.call(inMemoryTournamentCache, code)
        ? inMemoryTournamentCache[code]
        : undefined;

      if (entry !== undefined) {
        cacheHits++;
        updateCacheStatus();
        return entry; // may be null
      }

      // If a fetch for the same tournament code is already in-flight, await it
      if (pendingTournamentFetches[code]) {
        try {
          const result = await pendingTournamentFetches[code];
          // result may be null -> still counts as served (not a new miss here)
          return result;
        } catch (e) {
          return entry !== undefined ? entry : null;
        }
      }

      // start a new fetch and add to pending map to deduplicate
      cacheMisses++;
      updateCacheStatus();
      const url = `https://www.schachbund.de/turnier/${encodeURIComponent(code)}.html`;
      const fetchPromise = (async () => {
        try {
          const response = await fetch(`https://corsproxy.io/?${encodeURIComponent(url)}`);
          if (!response.ok) throw new Error(`HTTP ${response.status}`);
          const html = await response.text();
          const parser = new DOMParser();
          const doc = parser.parseFromString(html, 'text/html');
          const row = doc.querySelector('.row_3');
          const dateStr = row ? (row.querySelector('.col_2.value.bottom-line')?.textContent?.trim() || null) : null;
          // update in-memory cache only (persist later). store date string (or null).
          inMemoryTournamentCache[code] = dateStr;
          return dateStr;
        } catch (err) {
          console.error('Fehler Turnierdatum:', err);
          // on error, do not overwrite existing in-memory cache; return fallback
          return entry !== undefined ? entry : null;
        } finally {
          // pending fetch finished - remove entry
          delete pendingTournamentFetches[code];
        }
      })();

      pendingTournamentFetches[code] = fetchPromise;
      return await fetchPromise;
    }

    // Fetch the year of birth from the FIDE profile page for a given FIDE ID.
    async function fetchFideBirthYear(fideId) {
      if (!fideId) return null;
      try {
        const url = `https://ratings.fide.com/profile/${encodeURIComponent(fideId)}`;
        const response = await fetch(`https://corsproxy.io/?${encodeURIComponent(url)}`);
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        const html = await response.text();
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');
        const el = doc.querySelector('.profile-info-byear');
        const txt = el ? (el.textContent || '').trim() : null;
        const match = txt ? txt.match(/\d{4}/) : null;
        return match ? match[0] : (txt || null);
      } catch (err) {
        console.error('Fehler beim Laden FIDE-Geburtsjahr:', err);
        return null;
      }
    }

    function parseDateString(dateStr) {
      const parts = dateStr.split('.');
      if (parts.length !== 3) return null;
      const [day, month, year] = parts.map(x => parseInt(x, 10));
      return new Date(year, month - 1, day);
    }

    async function fetchPlayerData(pkz, color) {
      // ensure run-local cache exists (in case fetchTournamentDate wasn't called yet)
      if (!inMemoryTournamentCache) inMemoryTournamentCache = loadTournamentCache();

       const targetUrl = `https://www.schachbund.de/php/dewis/spieler.php?pkz=${encodeURIComponent(pkz)}&format=csv`;
       const corsUrl = `https://corsproxy.io/?${encodeURIComponent(targetUrl)}`;
   const playerSection = document.createElement('div');
   playerSection.className = 'player-section';
   const loadingH2 = document.createElement('h2');
   loadingH2.textContent = `Spieler ${pkz}`;
   const loadingP = document.createElement('p');
   loadingP.textContent = 'Lade Daten...';
   playerSection.appendChild(loadingH2);
   playerSection.appendChild(loadingP);
       document.getElementById('playersContainer').appendChild(playerSection);

       try {
        const response = await fetch(corsUrl);
        if (!response.ok) throw new Error(`HTTP-Fehler: ${response.status}`);
        const csv = await response.text();
        const rows = csv.trim().split('\n').map(r => r.split('|'));

        // ✅ Get player's name from second row, third column
        const playerName = rows[1]?.[2]?.trim() || `Spieler ${pkz}`;
        // FIDE ID is in row 2, column 7 (index 6). Extract the digit sequence (variable length).
        const fideRaw = rows[1]?.[6]?.trim();
        const fideMatch = fideRaw ? fideRaw.match(/\d+/) : null;
        const fideId = fideMatch ? fideMatch[0] : '';

        // Try to load FIDE year of birth (best-effort; may be null)
        let fideYear = null;
        if (fideId) {
          try { fideYear = await fetchFideBirthYear(fideId); } catch (e) { fideYear = null; }
        }

        // include FIDE id and birth year (if available) in the displayed title
        const playerTitle = playerName
          + (fideId ? ` (FIDE ${fideId})` : '')
          + (fideYear ? ` - geb. ${fideYear}` : '');

        // ✅ Dynamically find header row by "turniercode"
        const headerIndex = rows.findIndex(
          r => r[0] && r[0].trim().toLowerCase() === 'turniercode'
        );
        if (headerIndex === -1) {
          playerSection.innerHTML = '';
          const h = document.createElement('h2');
          h.textContent = playerTitle;
          const p = document.createElement('p');
          p.style.color = 'red';
          p.textContent = 'Keine Kopfzeile ("turniercode") gefunden.';
          playerSection.appendChild(h);
          playerSection.appendChild(p);
          return null;
        }

  const headers = rows[headerIndex] || [];
  const dataRows = rows.slice(headerIndex + 1); // keep all data rows

        if (dataRows.length === 0) {
          playerSection.innerHTML = '';
          const h = document.createElement('h2');
          h.textContent = playerTitle;
          const p = document.createElement('p');
          p.textContent = 'Keine Datenzeilen gefunden.';
          playerSection.appendChild(h);
          playerSection.appendChild(p);
          return null;
        }

        // ✅ Case-insensitive match for DWZneu column
        const dwzIndex = headers.findIndex(h => h.trim().toLowerCase() === 'dwzneu');

        // ✅ Collect tournament codes
        const tournaments = dataRows.map(r => r[0]?.trim()).filter(Boolean);

        // ✅ Fetch tournament dates in parallel
        const dateResults = await Promise.allSettled(
          tournaments.map(code => fetchTournamentDate(code))
        );

        // ✅ Build table
        const table = document.createElement('table');
        const thead = document.createElement('thead');
        const tbody = document.createElement('tbody');

        const headerRow = document.createElement('tr');
        headers.forEach(h => {
          const th = document.createElement('th');
          th.textContent = (h || '').trim();
          headerRow.appendChild(th);
        });
        const thDate = document.createElement('th');
        thDate.textContent = 'Turnierdatum';
        headerRow.appendChild(thDate);
        thead.appendChild(headerRow);

        const chartPoints = [];

        // Build list of tournament codes with their original dataRows index so
        // the dateResults can be mapped back to the correct row even if some
        // codes are missing/empty.
        const tournamentsWithIndex = dataRows
          .map((r, idx) => ({ code: (r && r[0]) ? r[0].trim() : '', idx }))
          .filter(t => t.code);

        // Map settled results back to original row indices
        const dateMap = {};
        dateResults.forEach((res, i) => {
          const info = tournamentsWithIndex[i];
          if (!info) return;
          dateMap[info.idx] = res.status === 'fulfilled' ? res.value : null;
        });

        dataRows.forEach((row, i) => {
          const tr = document.createElement('tr');
          (row || []).forEach(cell => {
            const td = document.createElement('td');
            td.textContent = (cell || '').trim();
            tr.appendChild(td);
          });

          const dateStr = dateMap[i] || null;
          const dateTd = document.createElement('td');
          dateTd.textContent = dateStr || 'Unbekannt';
          tr.appendChild(dateTd);
          tbody.appendChild(tr);

          const dwzValue = dwzIndex >= 0 && (row && row[dwzIndex]) ? parseInt((row[dwzIndex] || '').trim(), 10) : NaN;
          const dateObj = parseDateString(dateStr || '');
          if (dateObj instanceof Date && !isNaN(dateObj) && !isNaN(dwzValue)) {
            chartPoints.push({ x: dateObj, y: dwzValue });
          }
        });

        table.appendChild(thead);
        table.appendChild(tbody);
  // Avoid inserting untrusted HTML into innerHTML; use textContent instead
  playerSection.innerHTML = '';
  const h2 = document.createElement('h2');
  h2.textContent = playerTitle;
  playerSection.appendChild(h2);
  playerSection.appendChild(table);

        chartPoints.sort((a, b) => a.x - b.x);

        console.log(`✅ ${playerName}: ${chartPoints.length} Punkte`, chartPoints);

        // Persist run-local cache back to localStorage after this player's processing.
        // This avoids races where parallel fetchTournamentDate calls repeatedly
        // read/update localStorage and overwrite each other.
        try { saveTournamentCache(inMemoryTournamentCache); } catch (e) { /* ignore */ }

         // return fideYear as well for age-adjustment logic
         return { pkz, playerName, data: chartPoints, color, fideYear };

       } catch (err) {
        playerSection.innerHTML = '';
        const h = document.createElement('h2');
        // If we have the parsed playerName/yob, show it; otherwise fallback to pkz
        h.textContent = (typeof playerTitle !== 'undefined' && playerTitle) ? playerTitle : `Spieler ${pkz}`;
        const p = document.createElement('p');
        p.style.color = 'red';
        p.textContent = `Fehler: ${err.message}`;
        playerSection.appendChild(h);
        playerSection.appendChild(p);
        console.error(err);
        return null;
      }
    }

    // Build datasets (with optional age-adjust) and render chart for given players
    function renderChartFromPlayers(players) {
      const chartCanvas = document.getElementById('dwzChart');
      if (chartCanvas.chart) chartCanvas.chart.destroy();
      if (!players || players.length === 0) return;

      let ageAdjust = !!document.getElementById('ageAdjustCheckbox').checked;
      let firstYear = null;
      if (ageAdjust) {
        firstYear = players[0].fideYear ? parseInt(players[0].fideYear, 10) : null;
        if (!firstYear) {
          console.warn('Altersanpassung aktiviert, aber Geburtsjahr des ersten Spielers fehlt. Anpassung wird übersprungen.');
          ageAdjust = false;
        }
      }

      const datasets = players.map((p, idx) => {
        let data = (p.data || []).map(pt => ({ x: new Date(pt.x.getTime()), y: pt.y }));

        if (ageAdjust && idx !== 0) {
          const otherYear = p.fideYear ? parseInt(p.fideYear, 10) : null;
          if (otherYear) {
            const shift = firstYear - otherYear; // add difference in years
            data = data.map(pt => {
              const d = new Date(pt.x.getTime());
              d.setFullYear(d.getFullYear() + shift);
              return { x: d, y: pt.y };
            });
          } else {
            console.warn(`Geburtsjahr für ${p.playerName} fehlt; Anpassung übersprungen.`);
          }
        }

        return {
          label: p.playerName,
          data,
          borderColor: p.color,
          backgroundColor: p.color + '33',
          fill: false,
          tension: 0.3
        };
      }).filter(ds => ds.data && ds.data.length > 0);

      if (datasets.length === 0) return;

      chartCanvas.chart = new Chart(chartCanvas, {
        type: 'line',
        data: { datasets },
        options: {
          responsive: true,
          plugins: { legend: { display: true, position: 'bottom' } },
          scales: {
            x: { type: 'time', time: { unit: 'day', tooltipFormat: 'dd.MM.yyyy' }, title: { display: true, text: 'Turnierdatum' } },
            y: { title: { display: true, text: 'DWZneu' }, beginAtZero: false }
          }
        }
      });
    }

    document.getElementById('fetchBtn').addEventListener('click', async () => {
       // reset cache visual counters on each new run so the widget reflects this run
       cacheHits = 0;
       cacheMisses = 0;
       // initialize run-local cache from localStorage once
       inMemoryTournamentCache = loadTournamentCache();
       updateCacheStatus();

       const input = document.getElementById('pkz').value.trim();
       // remember last-used player list
       savePreviousInput(input);
       const ids = input.split(',').map(x => x.trim()).filter(Boolean);
       const container = document.getElementById('playersContainer');
       container.innerHTML = '';

       if (ids.length === 0) {
         container.innerHTML = '<p style="color:red;">Bitte mindestens eine Spieler-ID angeben.</p>';
         return;
       }

       // Fetch all players first (keeps original order)
       const players = [];
       for (let i = 0; i < ids.length; i++) {
         const color = chartColors[i % chartColors.length];
         const playerData = await fetchPlayerData(ids[i], color);
         if (playerData) players.push(playerData);
       }

       if (players.length === 0) return;

       // store players and render chart (render will respect checkbox state)
       lastPlayers = players;
       renderChartFromPlayers(players);
    });

    // Re-render when age-adjust checkbox changes
    document.getElementById('ageAdjustCheckbox').addEventListener('change', () => {
      if (lastPlayers) renderChartFromPlayers(lastPlayers);
    });
  </script>
</body>

</html>