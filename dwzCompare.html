<!DOCTYPE html>
<html lang="de">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Schachbund Multi-Spieler DWZ Chart</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 40px;
      background-color: #f7f7f7;
    }

    h1 {
      color: #333;
      margin-bottom: 10px;
    }

    input,
    button {
      display: block;
      margin-top: 10px;
      width: 100%;
      font-size: 1rem;
      padding: 8px;
    }

    button {
      background-color: #0077cc;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }

    button:hover {
      background-color: #005fa3;
    }

    .player-section {
      margin-top: 40px;
      background: white;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 10px;
    }

    th,
    td {
      border: 1px solid #ddd;
      padding: 6px 10px;
      text-align: left;
    }

    th {
      background-color: #0077cc;
      color: white;
    }

    tr:nth-child(even) {
      background-color: #f2f2f2;
    }

    #chartContainer {
      margin-top: 50px;
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
    }

    /* Cache status widget */
    #cacheStatus {
      position: fixed;
      right: 12px;
      bottom: 12px;
      background: #ffffffcc;
      backdrop-filter: blur(4px);
      padding: 8px 10px;
      border: 1px solid #ddd;
      border-radius: 6px;
      font-size: 12px;
      color: #222;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.08);
      z-index: 9999;
    }

    /* Chart controls placed above player tables */
    #chartArea {
      margin-top: 20px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .chart-controls {
      display: flex;
      align-items: center;
      justify-content: flex-start;
      gap: 8px;
    }

    /* Ensure checkbox is not stretched by the generic input rule */
    .chart-controls input[type="checkbox"] {
      display: inline-block;
      width: auto;
      height: auto;
      margin: 0;
      transform: scale(1.05);
      cursor: pointer;
    }

    .chart-controls label {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      cursor: pointer;
      font-size: 14px;
      color: #222;
    }

    /* Modal for Add top players */
    #topPlayersModalOverlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.4);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 10000;
    }

    #topPlayersModal {
      background: #fff;
      padding: 16px;
      border-radius: 6px;
      width: 360px;
      max-width: calc(100% - 32px);
      box-shadow: 0 6px 24px rgba(0, 0, 0, 0.2);
    }

    #topPlayersModal label {
      display: block;
      margin-top: 8px;
      font-size: 13px;
    }

    #topPlayersModal input,
    #topPlayersModal select {
      width: 100%;
      padding: 6px;
      margin-top: 4px;
      box-sizing: border-box;
    }

    #topPlayersModal .modal-actions {
      display: flex;
      gap: 8px;
      justify-content: flex-end;
      margin-top: 12px;
    }
  </style>
</head>

<body>
  <h1>DWZ-Verlauf mehrerer Spieler</h1>

  <div style="display:flex; align-items:center; gap:8px;">
    <label for="pkz" style="margin-right:6px;">Spieler-IDs (kommagetrennt):</label>
    <a id="addTopPlayersLink" href="#" style="margin-left:6px; text-decoration:underline; font-size:0.95rem; color:#0077cc;">Add top players</a>
  </div>
  <input type="text" id="pkz" placeholder="z. B. 12345,67890">

  <!-- Months control: number of months to load (0 = all). Default 12 -->
  <div style="margin-top:8px; max-width:320px;">
    <label for="months">Zeitraum (Monate, 0 = alle):</label>
    <input type="number" id="months" min="0" step="1" value="12" style="width:100%; font-size:1rem; padding:6px;">
  </div>

  <button id="fetchBtn">Daten abrufen</button>

  <!-- Chart and controls moved above the player tables -->
  <div id="chartArea">
    <div id="chartContainer">
      <canvas id="dwzChart" width="800" height="400"></canvas>
    </div>

    <!-- Player visibility toggles (populated at runtime) -->
    <div id="playerToggles" style="margin-top:10px; display:flex; flex-wrap:wrap; gap:8px;"></div>

    <div class="chart-controls">
      <label for="ageAdjustCheckbox"><input type="checkbox" id="ageAdjustCheckbox"> Altersanpassung</label>
    </div>
  </div>

  <div id="playersContainer"></div>

  <!-- Visual cache status (updated at runtime) -->
  <div id="cacheStatus" aria-live="polite" title="Cache-Treffer / -Fehler">Cache: Hits 0 · Misses 0</div>

  <!-- Top players modal -->
  <div id="topPlayersModalOverlay" role="dialog" aria-modal="true">
    <div id="topPlayersModal" role="document">
      <h3 style="margin:0 0 8px 0; font-size:1.05rem;">Add top players</h3>
      <label for="topLand">Land (optional)</label>
      <select id="topLand">
        <!-- only two supported options: whole Germany (000) or Berlin (300) -->
        <option value="000">Deutschland (gesamt)</option>
        <option value="300">Berlin</option>
      </select>

      <label for="topMinAge">Min Alter</label>
      <input id="topMinAge" type="number" min="0" placeholder="z. B. 18">

      <label for="topMaxAge">Max Alter</label>
      <input id="topMaxAge" type="number" min="0" placeholder="z. B. 99">

      <label for="topSex">Geschlecht</label>
      <select id="topSex">
        <option value="both">beide</option>
        <option value="male">männlich</option>
        <option value="female">weiblich</option>
      </select>

      <label for="topMaxCount">Max. Anzahl Spieler</label>
      <input id="topMaxCount" type="number" min="1" value="10">

      <div class="modal-actions">
        <button id="topPlayersCancel" type="button">Abbrechen</button>
        <button id="topPlayersAdd" type="button">Add</button>
      </div>
    </div>
  </div>

  <!-- Chart.js + Luxon for time axis -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/luxon@3.3.0/build/global/luxon.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon@1.1.0/dist/chartjs-adapter-luxon.min.js"></script>

  <script>
    const chartColors = [
      '#0077cc', '#ff5733', '#28a745', '#9b59b6',
      '#ff9800', '#00bcd4', '#e91e63', '#795548'
    ];

    // --- Spieler CSV loader (load once, keep mapping name->ID in memory) ---
    // ID is column 0, Spielername is column 4 (0-based indices). The CSV is
    // large; we keep the map in memory for the runtime. We key by a
    // normalized lowercase name (remove spaces after commas etc.) to match
    // names scraped from the website.
    let spielerNameToIdMap = null;
    let spielerCsvLoadPromise = null;

    function normalizeSpielerName(s) {
      if (!s) return '';
      // collapse whitespace, remove spaces after commas, trim and lowercase
      return s.replace(/\s+/g, ' ').replace(/,\s*/g, ',').trim().toLowerCase();
    }

    async function loadSpielerCsv() {
      if (spielerNameToIdMap) return spielerNameToIdMap;
      if (spielerCsvLoadPromise) return spielerCsvLoadPromise;

      // start loading and store promise to deduplicate concurrent requests
      spielerCsvLoadPromise = (async () => {
        // Try fetching the CSV from the server first. If that fails (for
        // example when the page is opened via file:// and fetch is blocked),
        // fall back to prompting the user to select the CSV file via a file
        // picker and read it locally.
        try {
          let text = null;
          try {
            const resp = await fetch('spieler.csv');
            if (resp && resp.ok) {
              text = await resp.text();
            } else {
              // treat non-ok like failure and fall through to file picker
              console.warn('spieler.csv fetch failed or returned non-ok response; falling back to file picker.');
            }
          } catch (fetchErr) {
            console.warn('Fetch spieler.csv failed (likely due to file:// CORS). Falling back to file picker.', fetchErr);
          }

          if (text === null) {
            // prompt user to choose the CSV file from disk
            text = await promptLoadSpielerCsvFile();
            if (!text) {
              // user cancelled or file empty -> return empty map
              spielerNameToIdMap = new Map();
              return spielerNameToIdMap;
            }
          }

          const lines = text.split(/\r?\n/);
          const map = new Map();
          // skip header if present
          let startIdx = 0;
          if (lines.length && lines[0].toLowerCase().includes('spielername')) startIdx = 1;

          // simple CSV parsing that handles quoted fields with commas
          for (let i = startIdx; i < lines.length; i++) {
            const line = lines[i];
            if (!line) continue;
            const fields = parseCsvLine(line);
            if (!fields || fields.length < 5) continue;
            const id = (fields[0] || '').trim();
            let name = (fields[4] || '').trim();
            // strip surrounding quotes if any
            if (name.startsWith('"') && name.endsWith('"')) name = name.slice(1, -1);
            const key = normalizeSpielerName(name);
            if (key && id) {
              // prefer first occurrence; duplicates typically have same ID
              if (!map.has(key)) map.set(key, id);
            }
          }
          spielerNameToIdMap = map;
          return map;
        } catch (err) {
          console.error('Error loading spieler.csv', err);
          spielerNameToIdMap = new Map();
          return spielerNameToIdMap;
        }
      })();

      return spielerCsvLoadPromise;
    }

    // parse a CSV line into fields, handling quoted fields containing commas
    function parseCsvLine(line) {
      const res = [];
      let cur = '';
      let inQuotes = false;
      for (let i = 0; i < line.length; i++) {
        const ch = line[i];
        if (ch === '"') {
          // toggle quote state. Handle double quotes inside quoted fields.
          if (inQuotes && line[i + 1] === '"') {
            cur += '"';
            i++; // skip escaped quote
          } else {
            inQuotes = !inQuotes;
          }
        } else if (ch === ',' && !inQuotes) {
          res.push(cur);
          cur = '';
        } else {
          cur += ch;
        }
      }
      res.push(cur);
      return res;
    }

    // Prompt the user to select the local `spieler.csv` file and return its text.
    // Returns null if the user cancels.
    function promptLoadSpielerCsvFile() {
      return new Promise((resolve) => {
        try {
          const input = document.createElement('input');
          input.type = 'file';
          input.accept = '.csv,text/csv';
          input.style.display = 'none';
          document.body.appendChild(input);
          input.addEventListener('change', () => {
            const file = input.files && input.files[0];
            if (!file) {
              document.body.removeChild(input);
              resolve(null);
              return;
            }
            const reader = new FileReader();
            reader.onload = () => {
              document.body.removeChild(input);
              resolve(reader.result || '');
            };
            reader.onerror = () => {
              document.body.removeChild(input);
              console.error('Error reading selected spieler.csv file');
              resolve(null);
            };
            reader.readAsText(file, 'utf-8');
          }, { once: true });
          // trigger file picker
          input.click();
        } catch (e) {
          console.error('Could not open file picker for spieler.csv', e);
          resolve(null);
        }
      });
    }

    // Simple localStorage cache for tournament dates
    const TOURNAMENT_CACHE_KEY = 'ch_tournament_dates_v2';
    // Tournament dates are fixed; do not expire in the cache.

    // Previous player input key + helpers
    const PREV_INPUT_KEY = 'ch_prev_pkz_v1';
    const AGE_ADJUST_KEY = 'ch_age_adjust_v1';
    const PKZ_YEAR_CACHE_KEY = 'ch_pkz_years_v1';
    const MONTHS_KEY = 'ch_months_v1';
    // load/save helpers for pkz -> birth year cache
    function loadPkzYearCache() {
      try { return JSON.parse(localStorage.getItem(PKZ_YEAR_CACHE_KEY) || '{}'); }
      catch (e) { return {}; }
    }
    function savePkzYearCache(cache) {
      try { localStorage.setItem(PKZ_YEAR_CACHE_KEY, JSON.stringify(cache)); }
      catch (e) { /* ignore */ }
    }
    // in-memory pkz->year cache for the current run
    let inMemoryPkzYearCache = null;

    function loadPreviousInput() {
      try { return localStorage.getItem(PREV_INPUT_KEY) || ''; }
      catch (e) { return ''; }
    }
    function savePreviousInput(value) {
      try { localStorage.setItem(PREV_INPUT_KEY, value || ''); }
      catch (e) { /* ignore storage errors */ }
    }

    function loadAgeAdjust() {
      try { return localStorage.getItem(AGE_ADJUST_KEY) === '1'; }
      catch (e) { return false; }
    }
    function saveAgeAdjust(v) {
      try { localStorage.setItem(AGE_ADJUST_KEY, v ? '1' : '0'); }
      catch (e) { /* ignore */ }
    }

    function loadMonths() {
      try { const v = parseInt(localStorage.getItem(MONTHS_KEY), 10); return isNaN(v) ? 12 : v; }
      catch (e) { return 12; }
    }
    function saveMonths(v) {
      try { localStorage.setItem(MONTHS_KEY, (Number.isFinite(v) ? String(v) : '12')); }
      catch (e) { /* ignore */ }
    }

    function loadTournamentCache() {
      try { return JSON.parse(localStorage.getItem(TOURNAMENT_CACHE_KEY) || '{}'); }
      catch (e) { return {}; }
    }
    function saveTournamentCache(cache) {
      try { localStorage.setItem(TOURNAMENT_CACHE_KEY, JSON.stringify(cache)); }
      catch (e) { /* ignore storage errors */ }
    }
    // restore previous input on page load
    try {
      const prev = loadPreviousInput();
      if (prev) document.getElementById('pkz').value = prev;
      // restore saved age-adjust checkbox state
      const cb = document.getElementById('ageAdjustCheckbox');
      if (cb) cb.checked = loadAgeAdjust();
      // restore months value
      const monthsEl = document.getElementById('months');
      if (monthsEl) monthsEl.value = loadMonths();
    } catch (e) { /* ignore */ }

    // In-memory shared cache for the current run to avoid localStorage race overwrites
    // and to reuse loaded entries across parallel fetchTournamentDate calls.
    // It is initialized once per "run" (button click) and persisted back
    // to localStorage after each player's data has been processed.
    let inMemoryTournamentCache = null;
    // pending fetch promises to deduplicate simultaneous remote lookups for same code
    const pendingTournamentFetches = {};

    // last fetched players for re-rendering when checkbox changes
    let lastPlayers = null;

    // Visual cache counters + updater
    let cacheHits = 0;
    let cacheMisses = 0;
    const cacheStatusEl = document.getElementById('cacheStatus');
    function updateCacheStatus() {
      if (!cacheStatusEl) return;
      // show number of cached entries as well (use in-memory cache if available,
      // otherwise read from localStorage)
      const cacheSource = inMemoryTournamentCache || loadTournamentCache();
      const size = cacheSource ? Object.keys(cacheSource).length : 0;
      cacheStatusEl.textContent = `Cache: Hits ${cacheHits} · Misses ${cacheMisses} · Einträge ${size}`;
    }

    // If a cached entry exists, return it. Otherwise fetch and store.
    async function fetchTournamentDate(tournamentCode) {
      if (!tournamentCode) return null;
      // Ensure we have the run-local cache loaded once
      if (!inMemoryTournamentCache) {
        inMemoryTournamentCache = loadTournamentCache();
      }

      const code = (tournamentCode || '').trim();
      // cache stores the date string (or null) directly. presence (not undefined)
      // indicates a cached value that never expires.
      const entry = Object.prototype.hasOwnProperty.call(inMemoryTournamentCache, code)
        ? inMemoryTournamentCache[code]
        : undefined;

      if (entry !== undefined) {
        cacheHits++;
        updateCacheStatus();
        return entry; // may be null
      }

      // If a fetch for the same tournament code is already in-flight, await it
      if (pendingTournamentFetches[code]) {
        try {
          const result = await pendingTournamentFetches[code];
          // result may be null -> still counts as served (not a new miss here)
          return result;
        } catch (e) {
          return entry !== undefined ? entry : null;
        }
      }

      // start a new fetch and add to pending map to deduplicate
      cacheMisses++;
      updateCacheStatus();
      const url = `https://www.schachbund.de/turnier/${encodeURIComponent(code)}.html`;
      const fetchPromise = (async () => {
        try {
          const response = await fetch(`https://corsproxy.io/?${encodeURIComponent(url)}`);
          if (!response.ok) throw new Error(`HTTP ${response.status}`);
          const html = await response.text();
          const parser = new DOMParser();
          const doc = parser.parseFromString(html, 'text/html');
          const row = doc.querySelector('.row_3');
          const dateStr = row ? (row.querySelector('.col_2.value.bottom-line')?.textContent?.trim() || null) : null;
          // update in-memory cache only (persist later). store date string (or null).
          inMemoryTournamentCache[code] = dateStr;
          return dateStr;
        } catch (err) {
          console.error('Fehler Turnierdatum:', err);
          // on error, do not overwrite existing in-memory cache; return fallback
          return entry !== undefined ? entry : null;
        } finally {
          // pending fetch finished - remove entry
          delete pendingTournamentFetches[code];
        }
      })();

      pendingTournamentFetches[code] = fetchPromise;
      return await fetchPromise;
    }

    // Fetch the year of birth from the FIDE profile page for a given FIDE ID.
    async function fetchFideBirthYear(fideId) {
      if (!fideId) return null;
      try {
        const url = `https://ratings.fide.com/profile/${encodeURIComponent(fideId)}`;
        const response = await fetch(`https://corsproxy.io/?${encodeURIComponent(url)}`);
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        const html = await response.text();
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');
        const el = doc.querySelector('.profile-info-byear');
        const txt = el ? (el.textContent || '').trim() : null;
        const match = txt ? txt.match(/\d{4}/) : null;
        return match ? match[0] : (txt || null);
      } catch (err) {
        console.error('Fehler beim Laden FIDE-Geburtsjahr:', err);
        return null;
      }
    }

    function parseDateString(dateStr) {
      const parts = dateStr.split('.');
      if (parts.length !== 3) return null;
      const [day, month, year] = parts.map(x => parseInt(x, 10));
      return new Date(year, month - 1, day);
    }

    // now accepts cutoffDate: null = load all tournaments; Date = cutoff to stop fetching older tournaments
    async function fetchPlayerData(pkz, color, cutoffDate) {
      // ensure run-local caches exist (in case fetchTournamentDate wasn't called yet)
      if (!inMemoryTournamentCache) inMemoryTournamentCache = loadTournamentCache();
      if (!inMemoryPkzYearCache) inMemoryPkzYearCache = loadPkzYearCache();

      const targetUrl = `https://www.schachbund.de/php/dewis/spieler.php?pkz=${encodeURIComponent(pkz)}&format=csv`;
      const corsUrl = `https://corsproxy.io/?${encodeURIComponent(targetUrl)}`;
      const playerSection = document.createElement('div');
      playerSection.className = 'player-section';
      const loadingH2 = document.createElement('h2');
      loadingH2.textContent = `Spieler ${pkz}`;
      const loadingP = document.createElement('p');
      loadingP.textContent = 'Lade Daten...';
      playerSection.appendChild(loadingH2);
      playerSection.appendChild(loadingP);
      document.getElementById('playersContainer').appendChild(playerSection);

      try {
        const response = await fetch(corsUrl);
        if (!response.ok) throw new Error(`HTTP-Fehler: ${response.status}`);
        const csv = await response.text();
        const rows = csv.trim().split('\n').map(r => r.split('|'));

        // ✅ Get player's name from second row, third column
        const playerName = rows[1]?.[2]?.trim() || `Spieler ${pkz}`;
        // FIDE ID is in row 2, column 7 (index 6). Extract the digit sequence (variable length).
        const fideRaw = rows[1]?.[6]?.trim();
        const fideMatch = fideRaw ? fideRaw.match(/\d+/) : null;
        const fideId = fideMatch ? fideMatch[0] : '';

        // Try to load year of birth from pkz->year cache first.
        let fideYear = null;
        const pkzKey = (pkz || '').toString().trim();
        if (pkzKey && Object.prototype.hasOwnProperty.call(inMemoryPkzYearCache, pkzKey)) {
          fideYear = inMemoryPkzYearCache[pkzKey]; // may be null
        } else if (fideId) {
          // not cached for this pkz -> fetch via FIDE id and store mapping pkz -> year
          try {
            fideYear = await fetchFideBirthYear(fideId);
          } catch (e) {
            fideYear = null;
          }
          // cache mapping (store even if null to avoid re-fetch)
          if (pkzKey) {
            inMemoryPkzYearCache[pkzKey] = fideYear === undefined ? null : fideYear;
          }
        }

        // include FIDE id and birth year (if available) in the displayed title
        const playerTitle = playerName
          + (fideId ? ` (FIDE ${fideId})` : '')
          + (fideYear ? ` - geb. ${fideYear}` : '');

        // ✅ Dynamically find header row by "turniercode"
        const headerIndex = rows.findIndex(
          r => r[0] && r[0].trim().toLowerCase() === 'turniercode'
        );
        if (headerIndex === -1) {
          playerSection.innerHTML = '';
          const h = document.createElement('h2');
          h.textContent = playerTitle;
          const p = document.createElement('p');
          p.style.color = 'red';
          p.textContent = 'Keine Kopfzeile ("turniercode") gefunden.';
          playerSection.appendChild(h);
          playerSection.appendChild(p);
          return null;
        }

        const headers = rows[headerIndex] || [];
        const dataRows = rows.slice(headerIndex + 1); // keep all data rows

        if (dataRows.length === 0) {
          playerSection.innerHTML = '';
          const h = document.createElement('h2');
          h.textContent = playerTitle;
          const p = document.createElement('p');
          p.textContent = 'Keine Datenzeilen gefunden.';
          playerSection.appendChild(h);
          playerSection.appendChild(p);
          return null;
        }

        // ✅ Case-insensitive match for DWZneu column
        const dwzIndex = headers.findIndex(h => h.trim().toLowerCase() === 'dwzneu');

        // ✅ Collect tournament codes
        const tournaments = dataRows.map(r => r[0]?.trim()).filter(Boolean);

        const dateMap = {}; // map original dataRows index -> date string (or null)

        if (!cutoffDate) {
          // load all tournament dates in parallel (existing behavior)
          const dateResults = await Promise.allSettled(
            tournaments.map(code => fetchTournamentDate(code))
          );
          // Build list of tournament codes with their original dataRows index so
          // the dateResults can be mapped back to the correct row even if some
          // codes are missing/empty.
          const tournamentsWithIndex = dataRows
            .map((r, idx) => ({ code: (r && r[0]) ? r[0].trim() : '', idx }))
            .filter(t => t.code);
          dateResults.forEach((res, i) => {
            const info = tournamentsWithIndex[i];
            if (!info) return;
            dateMap[info.idx] = res.status === 'fulfilled' ? res.value : null;
          });
        } else {
          // cutoffDate provided -> load from last tournament backwards until we find a date older than cutoffDate
          // Build list of tournament codes with their original dataRows index
          const tournamentsWithIndex = dataRows
            .map((r, idx) => ({ code: (r && r[0]) ? r[0].trim() : '', idx }))
            .filter(t => t.code);

          // iterate from last to first and fetch sequentially, stop when older than cutoff is reached
          for (let k = tournamentsWithIndex.length - 1; k >= 0; k--) {
            const info = tournamentsWithIndex[k];
            const code = info.code;
            try {
              const dateStr = await fetchTournamentDate(code); // may be null
              dateMap[info.idx] = dateStr;
              // if we have a valid parsed date and it's older than cutoffDate -> keep it and stop
              if (dateStr) {
                const dt = parseDateString(dateStr);
                if (dt instanceof Date && !isNaN(dt) && dt < cutoffDate) {
                  break;
                }
              }
              // if dateStr is null/unknown, continue fetching earlier tournaments (we can't decide)
            } catch (e) {
              // on error, mark as null and continue
              dateMap[info.idx] = null;
            }
          }
        }

        // ✅ Build table
        const table = document.createElement('table');
        const thead = document.createElement('thead');
        const tbody = document.createElement('tbody');

        const headerRow = document.createElement('tr');
        headers.forEach(h => {
          const th = document.createElement('th');
          th.textContent = (h || '').trim();
          headerRow.appendChild(th);
        });
        const thDate = document.createElement('th');
        thDate.textContent = 'Turnierdatum';
        headerRow.appendChild(thDate);
        thead.appendChild(headerRow);

        const chartPoints = [];

        dataRows.forEach((row, i) => {
          const tr = document.createElement('tr');
          (row || []).forEach(cell => {
            const td = document.createElement('td');
            td.textContent = (cell || '').trim();
            tr.appendChild(td);
          });

          // if dateMap has no key for this index it means we did not fetch that tournament (months limiting)
          const hasFetched = Object.prototype.hasOwnProperty.call(dateMap, i);
          const dateStr = hasFetched ? dateMap[i] : undefined;
          const dateTd = document.createElement('td');
          dateTd.textContent = dateStr === undefined ? 'Nicht geladen' : (dateStr || 'Unbekannt');
          tr.appendChild(dateTd);
          tbody.appendChild(tr);

          const dwzValue = dwzIndex >= 0 && (row && row[dwzIndex]) ? parseInt((row[dwzIndex] || '').trim(), 10) : NaN;
          const dateObj = parseDateString(dateStr || '');
          if (dateObj instanceof Date && !isNaN(dateObj) && !isNaN(dwzValue)) {
            chartPoints.push({ x: dateObj, y: dwzValue });
          }
        });

        table.appendChild(thead);
        table.appendChild(tbody);
        // Avoid inserting untrusted HTML into innerHTML; use textContent instead
        playerSection.innerHTML = '';
        const h2 = document.createElement('h2');
        h2.textContent = playerTitle;
        playerSection.appendChild(h2);
        playerSection.appendChild(table);

        chartPoints.sort((a, b) => a.x - b.x);

        console.log(`✅ ${playerName}: ${chartPoints.length} Punkte`, chartPoints);

        // Persist run-local cache back to localStorage after this player's processing.
        // This avoids races where parallel fetchTournamentDate calls repeatedly
        // read/update localStorage and overwrite each other.
        try { saveTournamentCache(inMemoryTournamentCache); } catch (e) { /* ignore */ }
        try { if (inMemoryPkzYearCache) savePkzYearCache(inMemoryPkzYearCache); } catch (e) { /* ignore */ }

        // return fideYear as well for age-adjustment logic
        return { pkz, playerName, data: chartPoints, color, fideYear };

      } catch (err) {
        playerSection.innerHTML = '';
        const h = document.createElement('h2');
        // If we have the parsed playerName/yob, show it; otherwise fallback to pkz
        h.textContent = (typeof playerTitle !== 'undefined' && playerTitle) ? playerTitle : `Spieler ${pkz}`;
        const p = document.createElement('p');
        p.style.color = 'red';
        p.textContent = `Fehler: ${err.message}`;
        playerSection.appendChild(h);
        playerSection.appendChild(p);
        console.error(err);
        return null;
      }
    }

    // Build per-player visibility checkboxes under the chart.
    function buildPlayerToggles(players) {
      const container = document.getElementById('playerToggles');
      if (!container) return;
      container.innerHTML = '';
      players.forEach((p, idx) => {
        const key = `playerToggle_${idx}_${p.pkz || idx}`;
        const label = document.createElement('label');
        label.style.display = 'inline-flex';
        label.style.alignItems = 'center';
        label.style.gap = '6px';
        label.style.marginRight = '8px';
        const cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.id = key;
        cb.dataset.idx = idx;
        cb.checked = true; // default enabled
        cb.addEventListener('change', () => {
          // simply re-render using current lastPlayers - data already loaded
          if (lastPlayers) renderChartFromPlayers(lastPlayers);
        });
        const txt = document.createElement('span');
        txt.textContent = p.playerName || (`Spieler ${p.pkz || idx}`);
        label.appendChild(cb);
        label.appendChild(txt);
        container.appendChild(label);
      });
    }

    // Build datasets (with optional age-adjust) and render chart for given players
    function renderChartFromPlayers(players) {
      const chartCanvas = document.getElementById('dwzChart');
      if (chartCanvas.chart) chartCanvas.chart.destroy();
      if (!players || players.length === 0) return;

      // determine visibility from toggles (default visible)
      const visibility = players.map((p, idx) => {
        const id = `playerToggle_${idx}_${p.pkz || idx}`;
        const el = document.getElementById(id);
        return el ? !!el.checked : true;
      });

      let ageAdjust = !!document.getElementById('ageAdjustCheckbox').checked;
      let firstYear = null;
      if (ageAdjust) {
        firstYear = players[0].fideYear ? parseInt(players[0].fideYear, 10) : null;
        if (!firstYear) {
          console.warn('Altersanpassung aktiviert, aber Geburtsjahr des ersten Spielers fehlt. Anpassung wird übersprungen.');
          ageAdjust = false;
        }
      }

      const datasets = players.map((p, idx) => {
        let data = (p.data || []).map(pt => ({ x: new Date(pt.x.getTime()), y: pt.y }));

        if (ageAdjust && idx !== 0) {
          const otherYear = p.fideYear ? parseInt(p.fideYear, 10) : null;
          if (otherYear) {
            const shift = firstYear - otherYear; // add difference in years
            data = data.map(pt => {
              const d = new Date(pt.x.getTime());
              d.setFullYear(d.getFullYear() + shift);
              return { x: d, y: pt.y };
            });
          } else {
            console.warn(`Geburtsjahr für ${p.playerName} fehlt; Anpassung übersprungen.`);
          }
        }

        // respect visibility toggles: skip datasets when unchecked
        if (!visibility[idx]) return null;
        return {
          label: p.playerName,
          data,
          borderColor: p.color,
          backgroundColor: p.color + '33',
          fill: false,
          tension: 0.3
        };
      }).filter(Boolean).filter(ds => ds.data && ds.data.length > 0);

      if (datasets.length === 0) return;

      chartCanvas.chart = new Chart(chartCanvas, {
        type: 'line',
        data: { datasets },
        options: {
          responsive: true,
          plugins: { legend: { display: true, position: 'bottom' } },
          scales: {
            x: { type: 'time', time: { unit: 'day', tooltipFormat: 'dd.MM.yyyy' }, title: { display: true, text: 'Turnierdatum' } },
            y: { title: { display: true, text: 'DWZneu' }, beginAtZero: false }
          }
        }
      });
    }

    document.getElementById('fetchBtn').addEventListener('click', async () => {
      // reset cache visual counters on each new run so the widget reflects this run
      cacheHits = 0;
      cacheMisses = 0;
      // initialize run-local cache from localStorage once
      inMemoryTournamentCache = loadTournamentCache();
      updateCacheStatus();

      // read and persist months setting and compute a single cutoffDate (null = load all)
      const monthsEl = document.getElementById('months');
      const months = monthsEl ? parseInt(monthsEl.value, 10) || 0 : 12;
      saveMonths(Number.isFinite(months) ? months : 12);
      let cutoffDate = null;
      if (months && Number(months) > 0) {
        cutoffDate = new Date();
        cutoffDate.setMonth(cutoffDate.getMonth() - Number(months));
        console.log(`Global cutoff: ${cutoffDate.toISOString()} (months=${months})`);
      } else {
        console.log('Global cutoff: none (load all tournaments)');
      }

      const input = document.getElementById('pkz').value.trim();
      // remember last-used player list
      savePreviousInput(input);
      const ids = input.split(',').map(x => x.trim()).filter(Boolean);
      const container = document.getElementById('playersContainer');
      container.innerHTML = '';

      if (ids.length === 0) {
        container.innerHTML = '<p style="color:red;">Bitte mindestens eine Spieler-ID angeben.</p>';
        return;
      }

      // Fetch all players first (keeps original order)
      const players = [];
      for (let i = 0; i < ids.length; i++) {
        const color = chartColors[i % chartColors.length];
        const playerData = await fetchPlayerData(ids[i], color, cutoffDate);
        if (playerData) players.push(playerData);
      }

      if (players.length === 0) return;

      // store players and render chart (render will respect checkbox state)
      lastPlayers = players;
      // create per-player toggles (all checked by default)
      buildPlayerToggles(players);
      renderChartFromPlayers(players);
    });

    // Re-render when age-adjust checkbox changes
    (function () {
      const cb = document.getElementById('ageAdjustCheckbox');
      if (!cb) return;
      cb.addEventListener('change', () => {
        saveAgeAdjust(cb.checked);
        if (lastPlayers) renderChartFromPlayers(lastPlayers);
      });
    })();

    // === Add top-players modal handling ===
    (function () {
      const addTopPlayersLink = document.getElementById('addTopPlayersLink');
      const overlay = document.getElementById('topPlayersModalOverlay');
      const cancelBtn = document.getElementById('topPlayersCancel');
      const addBtn = document.getElementById('topPlayersAdd');
      const pkzInput = document.getElementById('pkz');

      if (!overlay) return; // modal not present -> nothing to do

      // Open modal when link is clicked
      if (addTopPlayersLink) {
        addTopPlayersLink.addEventListener('click', (e) => {
          e.preventDefault();
          overlay.style.display = 'flex';
          // focus first focusable element inside modal for accessibility
          const first = overlay.querySelector('select, input, button');
          if (first) first.focus();
        });
      }

      // Close modal when Cancel clicked
      if (cancelBtn) {
        cancelBtn.addEventListener('click', () => {
          overlay.style.display = 'none';
          if (addTopPlayersLink) addTopPlayersLink.focus();
        });
      }

      // Close when clicking outside the modal content (on overlay)
      overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
          overlay.style.display = 'none';
          if (addTopPlayersLink) addTopPlayersLink.focus();
        }
      });

      // Close on Escape key
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && overlay.style.display === 'flex') {
          overlay.style.display = 'none';
          if (addTopPlayersLink) addTopPlayersLink.focus();
        }
      });

      // Minimal Add button behavior: close and focus PKZ input (extend later to populate IDs)
      if (addBtn) {
        addBtn.addEventListener('click', async () => {
          // read modal values
          const count = (document.getElementById('topMaxCount')?.value || '').trim();
          const sexSel = (document.getElementById('topSex')?.value || 'both').trim();
          const minAge = (document.getElementById('topMinAge')?.value || '').trim();
          const maxAge = (document.getElementById('topMaxAge')?.value || '').trim();
          const land = (document.getElementById('topLand')?.value || '000').trim(); // '000' or '300'

          // map sex to expected param values (male -> m, female -> w), omit for 'both'
          let sexParam = '';
          if (sexSel === 'male') sexParam = 'm';
          else if (sexSel === 'female') sexParam = 'f';

          // build query params
          const params = [];
          if (count) params.push(`toplist=${encodeURIComponent(count)}`);
          if (sexParam) params.push(`sex=${encodeURIComponent(sexParam)}`);
          if (minAge) params.push(`age_from=${encodeURIComponent(minAge)}`);
          if (maxAge) params.push(`age_to=${encodeURIComponent(maxAge)}`);

          const base = `https://www.schachbund.de/verband/${encodeURIComponent(land)}.html`;
          const url = params.length ? `${base}?${params.join('&')}` : base;

          try {
            // fetch content via cors proxy and parse it
            const resp = await fetch(`https://corsproxy.io/?${encodeURIComponent(url)}`);
            if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
            const html = await resp.text();
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, 'text/html');

            const table = doc.getElementById('dewisTable');
            if (!table) {
              alert('Keine Spieler-Tabelle (dewisTable) gefunden.');
              overlay.style.display = 'none';
              if (addTopPlayersLink) addTopPlayersLink.focus();
              return;
            }

            const rows = Array.from(table.querySelectorAll('tr'));
            const names = [];
            for (const row of rows) {
              const cell = row.querySelector('td.col_2');
              if (!cell) continue;
              // player name is directly in the .col_2 cell
              const name = (cell.textContent || '').trim();
              if (name) names.push(name);
            }

            // print fetched player names to the browser console (one per line + summary)
            if (names.length > 0) {
              console.log(`Top players fetched (${names.length}):`);
              names.forEach((n, i) => console.log(`${i + 1}. ${n}`));
            } else {
              console.log('No player names found in dewisTable rows.');
            }

            if (names.length === 0) {
              alert('Keine Spieler-Links gefunden.');
            } else {
              // Try to convert fetched player NAMES to IDs using spieler.csv
              try {
                const map = await loadSpielerCsv();
                const mapped = [];
                const notFound = [];
                for (const n of names) {
                  const key = normalizeSpielerName(n);
                  const id = map.get(key);
                  if (id) mapped.push(id);
                  else notFound.push(n);
                }

                const pkzInput = document.getElementById('pkz');
                if (pkzInput) {
                  if (mapped.length > 0 && notFound.length === 0) {
                    // all mapped -> populate with IDs
                    pkzInput.value = mapped.join(',');
                  } else if (mapped.length > 0 && notFound.length > 0) {
                    // mixed -> combine mapped IDs plus original names for those not found
                    pkzInput.value = mapped.concat(notFound).join(',');
                    console.warn('Some top-player names could not be resolved to IDs:', notFound);
                  } else {
                    // none mapped -> keep original behaviour
                    pkzInput.value = names.join(',');
                    console.warn('No top-player names could be resolved to IDs. See console for details.');
                  }
                }
              } catch (err) {
                console.error('Error converting top player names to IDs:', err);
                const pkzInput = document.getElementById('pkz');
                if (pkzInput) pkzInput.value = names.join(',');
              }
            }
          } catch (err) {
            console.error('Fehler beim Laden der Topliste:', err);
            alert('Fehler beim Laden der Topliste. Details in Konsole.');
          } finally {
            overlay.style.display = 'none';
            if (addTopPlayersLink) addTopPlayersLink.focus();
          }
        });
      }
    })();
  </script>
</body>

</html>